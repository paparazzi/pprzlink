#!/usr/bin/env python3
'''
parse a PPRZLink protocol XML file and generate a Python implementation
for version 2.0 of the protocol
'''

from __future__ import print_function
import os, io
import pprz_template, pprz_parse

t = pprz_template.PPRZTemplate()



def generate_imports(file:io.TextIOWrapper) -> None:
    imports = """
##############################################################################
#                                                                            #
# This file have been automatically generated by the pprzlink generator tool #
#                                                                            #
##############################################################################

from pprzlink.message import PprzMessage,PprzMessageField
import typing,enum
from dataclasses import dataclass
    """
    file.write(imports)

def generate_one(file, xml:pprz_parse.PPRZXML, m:pprz_parse.PPRZMsg) -> None:
    template = """ 
class PprzMessage_${msg_name}(PprzMessage):
    \"\"\"
    Automatically generated class for parsing Paparazzi messages of type '${msg_name}'
    
    Message's description:
    ${msg_description}
    \"\"\"
    
    __slots__ = ()
    
    ${{fields:
    @dataclass
    class PprzMessageField_${field_name}(PprzMessageField):
        \"\"\"
        Automatically generated message field specification associated to the field '${field_name}'
        
        Field's description:
        ${description}
        \"\"\"
        
        ${values_enum_class_str}
        
        name = '${field_name}'
        typestr = '${raw_type}'
        val:typing.Optional[${py_type}] = None
        format = ${format}
        unit = ${unit}
        values = ${values_enum_class_name}
        alt_unit = ${alt_unit}
        alt_unit_coef = ${alt_unit_coef}
        
        def __init__(self) -> None:
            super().__init__('${field_name}','${type}')
        
        def __setattr__(self, __name: str, __value: typing.Any) -> None:
            if (__name != 'val'):
                return None
            return super().__setattr__(__name, __value)
            
        
        @property
        def python_typestring(self) -> str:
            return '${py_type}'
            
        @property
        def python_type(self) -> typing.Type:
            return ${py_type}

        @property        
        def python_simple_type(self) -> type:
            return ${py_simple_type}
    }}
    
    def __init__(self,component_id:int=0):
        self._class_id:int = ${class_id}
        self._class_name:str = '${class_name}'
        self._component_id:int = component_id
        self._id:int = ${msg_id}
        self._name:str = '${msg_name}'
        self.broadcasted:bool = ${msg_broadcast}
        
        self._fields:typing.Dict[str,PprzMessageField] = dict()
        self._fields_order:typing.List[str] = []
        ${{fields:
        self._fields_order.append('${field_name}')
        self._fields['${field_name}'] = self.PprzMessageField_${field_name}()
        }}
    
    ${{fields:
    @property
    def ${field_name}_(self) -> ${py_type}:
        \"\"\"
        Automatically generated property associated to the field's value of '${field_name}'
        
        Field's description:
        ${description}
        \"\"\"
        return self._fields['${field_name}'].val
        
    @${field_name}_.setter
    def ${field_name}_(self,value:${py_type}) -> None:
        assert isinstance(value,${py_simple_type})
        self._fields['${field_name}'].val = value
        
    @property
    def ${field_name}_full_field(self) -> PprzMessageField_${field_name}:
        \"\"\"
        Automatically generated property associated to the field '${field_name}'
        
        Field's description:
        ${description}
        \"\"\"
        return self.get_full_field('${field_name}')
        
    @${field_name}_full_field.setter
    def ${field_name}_full_field(self,value:PprzMessageField_${field_name}) -> None:
        assert isinstance(value,PprzMessageField)
        self.set_full_field('${field_name}',value)
    }}
            """
    
    t.write(file,template,{'msg_name': m.msg_name, 'msg_id' : m.id, 'msg_broadcast':m.broadcast,
                           'class_name' : xml.class_name, 'class_id' : xml.class_id ,
                           'fields': m.fields, 'msg_description': m.description})


def generate_inspector(file, xml:pprz_parse.PPRZXML, module_name:str):
    template = """
#!/usr/bin/env python3

##############################################################################
#                                                                            #
# This file have been automatically generated by the pprzlink generator tool #
#                                                                            #
##############################################################################

# Prints to stdout any of the messages defined in ${module_name}
# seen on the Ivy bus at address 127.255.255.255:2010

import pprzlink.ivy

from ${module_name} import *
import sys
import time

def log_callback(ac_id,pprzMsg) -> None:
    print(f"Received message {pprzMsg} from {ac_id}")
    

# Creation of the ivy interface
ivy = pprzlink.ivy.IvyMessagesInterface(
            agent_name="${module_name}_inspector",  # Ivy agent name
            start_ivy=False,                        # Do not start the ivy bus now
            ivy_bus="127.255.255.255:2010")         # address of the ivy bus

try:
    # starts the ivy interface
    ivy.start()

    ${{messages:
    ivy.subscribe(log_callback,PprzMessage_${msg_name}())
    }}
    
    print("Startup successful!")

    # Wait untill ^C is pressed
    while True:
        time.sleep(5)
except KeyboardInterrupt:
    ivy.shutdown()

    """
    t.write(file,template,{'module_name':module_name, 'messages':xml.message})

def generate(output:str, xml:pprz_parse.PPRZXML):
    '''generate complete Python statically parsed interface'''

    
    if os.path.isfile(output):
        directory, _ = os.path.split(output)
    else:
        directory = output
    if directory != '':
        pprz_parse.mkdir_p(directory)

    # print(f"Destination dir: {directory}")
    
    with open(os.path.join(directory,xml.class_name+".py"), mode='w') as file:
        generate_imports(file)
        for m in xml.message:
            generate_one(file,xml,m)
            
    # with open(os.path.join(directory,"__init__.py"), mode='w') as module_file:
    #     module_list = [m.msg_name for m in xml.message]
    #     module_file.write(f"__all__ = {str(module_list)}")
    
    with open(os.path.join(directory,xml.class_name+"_inspector.py"),mode='w') as inspector_file:
        generate_inspector(inspector_file,xml,xml.class_name)
