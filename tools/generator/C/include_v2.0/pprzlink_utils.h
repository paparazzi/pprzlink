/*
 * Copyright (C) 2016 Gautier Hattenberger <gautier.hattenberger@enac.fr>
 *
 * This file is part of paparazzi.
 *
 * paparazzi is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * paparazzi is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with paparazzi; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 */

/** \file pprzlink_utils.h
 *
 *  Utility macros and functions for PPRZLINK
 *
 * Reading macros to access incoming messages values (which might not be aligned).
 *
 * Define PPRZLINK_UNALIGNED_ACCESS to TRUE if the target CPU/MMU allows unaligned access.
 * This is true for x86/64 and most recent ARM platforms (ARMv7, Cortex-A, Cortex-M3/4).
 * Examples for targets WITHOUT unaligned access support: LPC21xx, Cortex-M0
 */

#ifndef PPRZLINK_UTILS_H
#define PPRZLINK_UTILS_H

#ifdef __cplusplus
extern "C" {
#endif

#define PPRZLINK_PROTOCOL_VERSION "2.0"

#include <inttypes.h>

// Single byte values are always aligned
#define _PPRZ_VAL_char(_payload, _offset) ((char)(*((uint8_t*)_payload+_offset)))
#define _PPRZ_VAL_int8_t(_payload, _offset) ((int8_t)(*((uint8_t*)_payload+_offset)))
#define _PPRZ_VAL_uint8_t(_payload, _offset) ((uint8_t)(*((uint8_t*)_payload+_offset)))
#define _PPRZ_VAL_char_array(_payload, _offset) ((char*)(_payload+_offset))
#define _PPRZ_VAL_int8_t_array(_payload, _offset) ((int8_t*)(_payload+_offset))
#define _PPRZ_VAL_uint8_t_array(_payload, _offset) ((uint8_t*)(_payload+_offset))

// Define unaligned types
typedef int16_t __attribute__((aligned(1))) int16_ual_t;
typedef uint16_t __attribute__((aligned(1))) uint16_ual_t;
typedef int32_t __attribute__((aligned(1))) int32_ual_t;
typedef uint32_t __attribute__((aligned(1))) uint32_ual_t;
typedef int64_t __attribute__((aligned(1))) int64_ual_t;
typedef uint64_t __attribute__((aligned(1))) uint64_ual_t;
typedef float __attribute__((aligned(1))) float_ual;
typedef double __attribute__((aligned(1))) double_ual;

// This way of reading is more efficient when data is actually aligned
// but is still working if the CPU/MMU supports unaligned access.
typedef union __attribute__((packed,aligned(1))) {
  int16_ual_t   int16;
  uint16_ual_t  uint16;
  int32_ual_t   int32;
  uint32_ual_t  uint32;
  int64_ual_t   int64;
  uint64_ual_t  uint64;
  float_ual     f32;
  double_ual    f64;
} unaligned_t;

// Macros to extract values of different types
#define _PPRZ_VAL_int16_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->int16)
#define _PPRZ_VAL_uint16_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->uint16)
#define _PPRZ_VAL_int32_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->int32)
#define _PPRZ_VAL_uint32_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->uint32)
#define _PPRZ_VAL_int64_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->int64)
#define _PPRZ_VAL_uint64_t(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->uint64)
#define _PPRZ_VAL_float(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->f32)
#define _PPRZ_VAL_double(_payload, _offset) (((unaligned_t*)((uint8_t *)_payload+_offset))->f64)

// If unaligned access is supported, these functions don't have overhead
// If it is not possible, proper code will be generated by the compiler with a little cost
// but still transparent for the user
static inline int16_ual_t * _PPRZ_VAL_int16_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_int16_t(_payload, _offset); }
static inline uint16_ual_t * _PPRZ_VAL_uint16_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_uint16_t(_payload, _offset); }
static inline int32_ual_t * _PPRZ_VAL_int32_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_int32_t(_payload, _offset); }
static inline uint32_ual_t * _PPRZ_VAL_uint32_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_uint32_t(_payload, _offset); }
static inline int64_ual_t * _PPRZ_VAL_int64_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_int64_t(_payload, _offset); }
static inline uint64_ual_t * _PPRZ_VAL_uint64_t_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_uint64_t(_payload, _offset); }
static inline float_ual * _PPRZ_VAL_float_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_float(_payload, _offset); }
static inline double_ual * _PPRZ_VAL_double_array(uint8_t *_payload, uint8_t _offset) { return &_PPRZ_VAL_double(_payload, _offset); }

// Get array length
#define _PPRZ_VAL_len_aligned(_payload, _offset) _PPRZ_VAL_uint8_t(_payload, _offset)
#define _PPRZ_VAL_fixed_len_aligned(_len) (_len)

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif // PPRZLINK_UTILS_H
